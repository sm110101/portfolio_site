<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>report – Sean Morris</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../assets/sm_logo.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-06PBVCH3LM"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-06PBVCH3LM', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Sean Morris">
<meta property="og:image" content="assets/sm_logo.png">
<meta property="og:site_name" content="Sean Morris">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../assets/sm_logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Sean Morris</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../report/report.html" aria-current="page"> 
<span class="menu-text">Report</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-technical-details" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Technical details</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-technical-details">    
        <li>
    <a class="dropdown-item" href="../technical-details/data-collection/main.html">
 <span class="dropdown-text">Data-collection</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../technical-details/data-cleaning/main.html">
 <span class="dropdown-text">Data-cleaning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../technical-details/eda/main.html">
 <span class="dropdown-text">Exploratory Data Analysis</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../technical-details/unsupervised-learning/main.html">
 <span class="dropdown-text">Unsupervised Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../technical-details/supervised-learning/main.html">
 <span class="dropdown-text">Supervised Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../technical-details/progress-log.html">
 <span class="dropdown-text">Progress Log</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../technical-details/llm-usage-log.html">
 <span class="dropdown-text">LLM usage Log</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/spm122/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/sm110101"> <i class="bi bi-twitter-x" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/sm110101"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.instagram.com/sean.morriss/"> <i class="bi bi-instagram" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#exploring-and-modeling-amazon-electronics-reviews" id="toc-exploring-and-modeling-amazon-electronics-reviews" class="nav-link active" data-scroll-target="#exploring-and-modeling-amazon-electronics-reviews">Exploring and Modeling Amazon Electronics Reviews</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data">Data</a></li>
  <li><a href="#exploring-the-data" id="toc-exploring-the-data" class="nav-link" data-scroll-target="#exploring-the-data">Exploring the data</a></li>
  <li><a href="#product-clusters" id="toc-product-clusters" class="nav-link" data-scroll-target="#product-clusters">Product Clusters</a></li>
  <li><a href="#running-predictions" id="toc-running-predictions" class="nav-link" data-scroll-target="#running-predictions">Running Predictions</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="exploring-and-modeling-amazon-electronics-reviews" class="level1">
<h1>Exploring and Modeling Amazon Electronics Reviews</h1>
<hr>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Every product review holds a story. These stories may span paragraphs of in-depth detail about the user’s experience, or offer a simple “works great!” In either case, the user felt compelled to offer their own perspective, creating a snapshot of their interaction with the product. These stories, delivered from countless different voices and tones, hold a treasure trove of information. They reveal customer satisfaction and provide clues on why certain products do well - or where they fall short. By analyzing these reviews, we can uncover trends that exist beyond individual opinions.</p>
<p>In this study, I leverage natural language processing techniques and machine learning models to explore the hidden structure of Amazon customer reviews. For the <a href="https://nijianmo.github.io/amazon/index.html">data</a>, I gathered over 6 million individual reviews from an open-source GitHub repository. Due to computational bottlenecks, I conducted my analysis using 100,000 randomly sampled reviews from the main data set.</p>
<p>As for the project goals, I first wanted to analyze which key terms appeared most frequently across different Amazon review ratings (on a 5-star scale). Next, I used a technique called clustering, which allowed me to extract the underlying patterns in the review text. For the final part of the project, I shifted my focus to predicting three different metrics associated with Amazon reviews.</p>
</section>
<section id="data" class="level2">
<h2 class="anchored" data-anchor-id="data">Data</h2>
<p>Before diving into the main parts of this study, I’d like to provide you with a quick summary of my data. All of the Amazon reviews used in this study come from the source linked above. The creator of the GitHub repository, <a href="https://x.com/jianmo_ni">Jianmo Ni</a>, is a former UCSD student who created the repository to store over 200 million Amazon reviews to be used for their paper on recommendation systems.<span class="citation" data-cites="DataArticle"><sup><a href="#ref-DataArticle" role="doc-biblioref">1</a></sup></span> The raw data came in the form of JSON, which structures data in human-readable form by using key-value pairs.</p>
<p><strong>Here is an example of a review in JSON:</strong> <br> <img src="../xtra/multiclass-portfolio-website/images/raw_data_json.png" class="img-fluid" width="600"> <br> <a href="https://cseweb.ucsd.edu/~jmcauley/datasets/amazon/links.html">Source</a> <br></p>
<p>In the <a href="../technical-details/data-cleaning/main.html">data cleaning</a> section of this website, I cover the steps taken to convert this data into a tabular format - similar to what you see in an excel sheet where each observation is a row, and each column represents a different variable or characteristic.</p>
</section>
<section id="exploring-the-data" class="level2">
<h2 class="anchored" data-anchor-id="exploring-the-data">Exploring the data</h2>
<section id="rating-skewness" class="level4">
<h4 class="anchored" data-anchor-id="rating-skewness">Rating Skewness</h4>
<p>To better understand the data, I began by looking at the different characteristics associated with reviews. A natural first step was to look at the frequency of different review ratings. “Rating” in this case refers to the score a user gives to a product - ranging from 1 to 5 stars. Most of the ratings for electronics were 5 stars, which ended up causing some issues down the line when I attempted to predict the rating of different reviews.</p>
</section>
<section id="patterns-in-text" class="level4">
<h4 class="anchored" data-anchor-id="patterns-in-text">Patterns in Text</h4>
<p>In the next part of my exploration, I shifted my focus to the review text itself. For this, I relied on a tool called a “document term matrix” that takes in raw text as an input, and returns a table where each row was a review, and each column represented a word found across all of our reviews. From there, I sorted the top 10 most frequently occurring words for each review rating and plotted them on different bar graphs. When using only single terms, the results were uninformative, with meaningless words occupying the top spots across all review ratings. To try and correct this, I instead looked at the top word pairs for each review rating, which gave much better results:</p>
<p><strong>Top Word Pairs by Rating</strong> <br> <img src="../xtra/multiclass-portfolio-website/images/report_plots/top_word_pairs.png" class="img-fluid"> <br> <a href="../technical-details/eda/main.html">Created by Author</a> <br></p>
<p>These plots provided much better context as to where certain words appear in different review scores, with pairs like “works great” and “highly recommend” appearing frequently in highly rated products, and pairs like “stopped working” and “waste money” appearing in lower rated reviews.</p>
</section>
</section>
<section id="product-clusters" class="level2">
<h2 class="anchored" data-anchor-id="product-clusters">Product Clusters</h2>
<section id="overview" class="level4">
<h4 class="anchored" data-anchor-id="overview">Overview</h4>
<p>To identify some deeper trends in our reviews data, I applied a suite of algorithms called “clustering” to group similar reviews together based on their context. In simple terms, clustering is a type of machine learning technique that groups together data points into “clusters” based on how close they are. This approach helped uncover some patterns that were impossible to recognize when looking only at the raw data.</p>
</section>
<section id="results" class="level4">
<h4 class="anchored" data-anchor-id="results">Results</h4>
<p>The clustering models yielded some interesting results - in which they were able to learn that different reviews applied to different products without me specifying exactly what those products were. In one example, two of our models found clusters where each point had predominant words like “camera”, “lens”, and “tripod”, reflecting a focus on photography-related products. In another case, our models grouped together points that included emotional and descriptive terms like “awesome” and “highly recommend”, capturing reviews with strong positive sentiment.</p>
<p><strong>The Camera Cluster (Orange Points)</strong> <br> <img src="../../xtra/multiclass-portfolio-website/images/kmeans_interactive/KMeans_camera.png" class="img-fluid" width="800"> <br> <a href="../technical-details/unsupervised-learning/main.html">Created by Author</a> <br></p>
<p>In this section, two of the clustering models used performed well while the third fell short. Overall, the methods used in this section helped reveal hidden patterns in the data - specifically how customer feedback is organized around different product types and overall sentiment.</p>
</section>
</section>
<section id="running-predictions" class="level2">
<h2 class="anchored" data-anchor-id="running-predictions">Running Predictions</h2>
<section id="overview-1" class="level4">
<h4 class="anchored" data-anchor-id="overview-1">Overview</h4>
<p>In the final stage of the analysis, I focus on predicting three specific outcomes based on the review data. For this, I leveraged techniques like binary classification (predicting outcome A or B), multi-class classification (predicting A, B, C, or D), and regression (predicting number <span class="math inline">\(y\)</span> based on input <span class="math inline">\(x\)</span>). For the target variables, I aimed to predict the sentiment of reviews (positive or negative), review rating (1-5), and review “polarity”. The term “polarity” is a proxy to our binary sentiment target, but instead of being a class like “positive” or “negative” it is a continuous value that falls in the range <span class="math inline">\((-1, \ 1)\)</span>. Values closer to -1 represent a more negative sentiment, while values closer to 1 represent a more positive sentiment.</p>
</section>
<section id="key-feature" class="level4">
<h4 class="anchored" data-anchor-id="key-feature">Key Feature</h4>
<p>In all of my models, I include the term frequency-inverse document frequency embeddings of the top 500 words across all of our reviews. In case you are unfamiliar, TF-IDF calculates the relevance of a given word with respect to both its rate of appearance in individual reviews and its frequency across all reviews. Its components can be broken up into “term frequency” and “inverse document frequency”. Term frequency (TF) calculates the rate at which a given term appears in a single document (or review in our case). This is done by dividing the number of times the term appears by the total number of words in the review. On the other hand, inverse document frequency (IDF) is calculated by taking the natural log of the total number of documents divided by the number of documents that contain the term. Multiplying the two terms together provides us with our TF-IDF score for the term. I chose to use TF-IDF as the embedding method for Amazon reviews because of its ability to punish words that have both high term frequency and document frequency. Since reviews are short and often repetitive, certain common words appear frequently but carry little contextual significance. TF-IDF helps to filter out these generic terms, allowing the models to focus on words that are more relevant for pattern recognition.</p>
</section>
<section id="predicting-sentiment" class="level4">
<h4 class="anchored" data-anchor-id="predicting-sentiment">Predicting Sentiment</h4>
<p>For sentiment prediction, the best performing model was able to accurately predict whether a given review was positive or negative in over 85% of cases. In order to achieve this result, I trained my model on only the top 500 TF-IDF embeddings. When I tried to add other features to the model like the number of community votes, or whether the reviewer’s account was verified, the performance remained the same. Additionally, when I tired running the model with all features besides the TF-IDF embeddings, its performance dropped significantly - reinforcing the idea that the text itself holds the most predictive power.</p>
</section>
<section id="predicting-rating" class="level4">
<h4 class="anchored" data-anchor-id="predicting-rating">Predicting Rating</h4>
<p>When trying to predict the actual star rating associated with different reviews, the task proved more challenging than simply predicting positive or negative reviews. The most accurate model in this section achieved around 65% accuracy in correctly predicting the star rating of different reviews. Each of the models performed the best at identifying 5-star reviews, which were by far the most common in the data set. However, because of the highly disproportionate number of higher rated reviews, the models performed very poorly when trying to classify lower rated reviews. To try and address this, I experimented with an undersampled data set that contained an equal amount of reviews for each rating class. While this method improved my model’s ability to predict lower rating reviews, it came with the cost of overall accuracy - where the average prediction accuracy for the undersampled data set was around 40%.</p>
<p><strong>Multi-class Confusion Matrix</strong></p>
<table>
<tbody><tr>
<td>
<strong>Before Undersampling</strong><br> <img src="../xtra/multiclass-portfolio-website/images/report_plots/cmat_before.png" width="350px">
</td>
<td>
<strong>After Undersampling</strong><br> <img src="../xtra/multiclass-portfolio-website/images/report_plots/cmat_after.png" width="350px">
</td>
</tr>
</tbody></table>
<p><br> <a href="../technical-details/supervised-learning/main.html">Created by Author</a> <br></p>
<p>The plots above display the confusion matrices of the best performing multi-class predictions, with the regular data set on the left and undersampled data set on the right. The most important characteristic of each confusion matrix is the values of their diagonal elements. Each value on the diagonal represents observations where both the predicted rating and actual rating are aligned. On the other hand, all of the off-diagonal elements represent misclassifications.</p>
<p>As you can see in the plots above, when applying multi-class prediction on the base data, the model is heavily biased toward predicting 5-star ratings. Fortunately, this bias pays off as the disproportionately high frequency of 5-star ratings will align nicely with the model’s bias and therefore ensure moderately high accuracy. In contrast, when I ran the same model on the undersampled data set, the resulting confusion matrix shows a more balanced distribution of class assignments (with slightly more bias toward 1-star and 5-star ratings). While a positive, the model’s more balanced predictions on the undersampled data led to a dramatic drop in performance. One likely reason for this drop in the lack of clear differentiation in the text patterns associated with moderate review scores (2-4 stars). To further back this up, the second model performed well in classifying reviews with the extreme values for rating (1 and 5 stars), which often have stronger and more discernable text patterns.</p>
</section>
<section id="polarity" class="level4">
<h4 class="anchored" data-anchor-id="polarity">Polarity</h4>
<p>For my final set of models, I chose to apply a regression-based approach to predicting sentiment. In simple terms, regression allows us to “predict or explain the variation in one variable based on another variable.”<span class="citation" data-cites="Regression"><sup><a href="#ref-Regression" role="doc-biblioref">2</a></sup></span> In the first section, I adopted a classification-based approach to predict whether a given review was “positive” or “negative”. In this section my motivations are similar, but instead of predicting a sentiment using a class-based framework, I want to model sentiment on a continuous scale. In order to do this, I created the target variable <code>polarity</code>. Polarity, as calculated by the <a href="https://textblob.readthedocs.io/en/dev/quickstart.html"><code>TextBlob</code></a> library, represents a continuous value in the range <span class="math inline">\((-1, \ 1)\)</span> where -1 is extremely negative sentiment and 1 is extremely positive sentiment. TextBlob calculates the polarity score for a string of text by scanning its content for both positive and negative sentiment-laden terms, assigning weights based on the intensity of each term. For example, a review with the phrase “absolutely terrible” will receive a polarity score closer to -1.</p>
</section>
<section id="predicting-polarity" class="level4">
<h4 class="anchored" data-anchor-id="predicting-polarity">Predicting Polarity</h4>
<p>To predict the polarity term defined above, I trained two different regression models that used the same features adopted for classification as their inputs - including the top 500 TF-IDF features extracted from the review text. The best performing model was the <a href="https://scikit-learn.org/dev/modules/generated/sklearn.ensemble.RandomForestRegressor.html">Random Forest Regressor</a> that only used the TF-IDF features for its input. The model achieved reasonable accuracy, explaining around 67% of the variation in polarity scores. This result further enforces the idea that review text alone contains the strongest signal for predicting sentiment - even on a continuous scale. While my regression models were able to capture general sentiment trends well, they faced a challenges when dealing with extreme outliers and noise in both the input and target data. In the <a href="../technical-details/supervised-learning/main.html">Supervised Learning</a> section of this website, I dive deeper into the technical details behind these issues, and my future plans to address them.</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>In this study, I demonstrate the value of analyzing customer reviews to uncover hidden trends, and offer predictions that can be used to inform improvements in product and customer satisfaction. By exploring reviews posted for products in the “Electronics” category of Amazon, I was able to group together product subcategories based solely on short review text, and predict both the star rating given to products as well as the sentiment of a review on a binary and continuous scale.</p>
<section id="key-takeaways" class="level4">
<h4 class="anchored" data-anchor-id="key-takeaways">Key Takeaways</h4>
<ol type="1">
<li><strong>Product Clusters</strong>: The clustering methods in this study uncovered groups of reviews categorized by product types and review sentiments. This insight could help businesses to better understand how their products are perceived in specific markets - allowing them to create data-driven strategies for product development and marketing.</li>
<li><strong>The Power of Text:</strong> In all methods of prediction across this study, the text of the review held the strongest predictive power for each target variable - outperforming other characteristics like community votes or verified status.</li>
<li><strong>Challenges with Imbalanced Data:</strong> The disproportionately high number of 5-star reviews impeded model accuracy when I went to predict review rating. Addressing this issue with undersampling helped begin to solve the problem, but the limited scope of the text data made predicting moderate review ratings more difficult.</li>
</ol>
</section>
<section id="recommendations" class="level4">
<h4 class="anchored" data-anchor-id="recommendations">Recommendations</h4>
<ol type="1">
<li><strong>Leverage Customer Feedback:</strong> Use findings to help address concerns raised in negative reviews, while bolstering strengths found in positive reviews.</li>
<li><strong>Monitor Sentiment:</strong> Consistently analyze changes in customer sentiment in order to proactively address any growing issues and improve overall satisfaction.</li>
</ol>



</section>
</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body" data-entry-spacing="0" data-line-spacing="2" role="list">
<div id="ref-DataArticle" class="csl-entry" role="listitem">
<div class="csl-left-margin">1. </div><div class="csl-right-inline">Jianmo Ni, J. M., Jiacheng Li. Justifying recommendations using distantly-labeled reviews and fine-grained aspects. (2019).</div>
</div>
<div id="ref-Regression" class="csl-entry" role="listitem">
<div class="csl-left-margin">2. </div><div class="csl-right-inline"><a href="https://www.westga.edu/academics/research/vrc/assets/docs/linear_regression_notes.pdf">Regression notes - diana mindrila, ph.d. (Based on chapter 5 of the basic practice of statistics (6th ed.))</a>.</div>
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>